import{_ as s,r as n,o as l,c as d,b as t,d as e,e as a,a as r}from"./app-53705635.js";const c={},o=t("h2",{id:"webassembly-simd",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#webassembly-simd","aria-hidden":"true"},"#"),e(),t("strong",null,"WebAssembly SIMD")],-1),p={href:"https://link.zhihu.com/?target=https%3A//www.chromestatus.com/feature/6533147810332672",target:"_blank",rel:"noopener noreferrer"},h={href:"https://link.zhihu.com/?target=https%3A//www.chromestatus.com/feature/6533147810332672",target:"_blank",rel:"noopener noreferrer"},m=t("strong",null,"S",-1),u=t("strong",null,"I",-1),b=t("strong",null,"M",-1),v=t("strong",null,"D",-1),f=r('<p>SIMD是一种特殊的CPU指令，它可以实现数据层面的并行处理。如下图，当我们需要对两个长度为4的数组做加法时，使用普通的指令，则需要执行4次普通加法指令；如果使用SIMD指令的话，则只需要执行1次向量加法即可：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f4f84cfa104a2384e016f56c83f329~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>SIMD常用于视频、音频、图像、加密、动画、游戏、AI等需要处理大量数据的应用场景，可以极大地提高向量类型的数据处理性能。主流的CPU都有SIMD指令，比如x86的SSE、ARM的Neon。</p><p>WebAssembly SIMD为WebAssembly新增了一个变量类型v128及其一系列v128的运算符，这些运算符就是SIMD指令。另外，由名字可知v128类型的长度是固定的，为128比特。</p><p>SIMD的指令非常多，而且不同CPU的SIMD是不一样的，WebAssembly SIMD只选取了各个CPU都支持的部分最常用的SIMD指令。因此，可以将WebAssembly SIMD理解为各个CPU的SIMD指令的子集，同时将各个CPU的SIMD指令进行了一层抽象和统一。</p><h3 id="websockets-over-http-2" tabindex="-1"><a class="header-anchor" href="#websockets-over-http-2" aria-hidden="true">#</a> WebSockets over HTTP/2</h3><p>Chrome 91支持基于HTTP/2的Websocket。</p><h3 id="block-http-port-10080" tabindex="-1"><a class="header-anchor" href="#block-http-port-10080" aria-hidden="true">#</a> Block HTTP port 10080</h3><p>为了缓解NAT Slipstream 2.0攻击，Chrome 91又屏蔽了一个新的端口：10080。</p><p>自从去年11月底NAT Splipstream被发现以来，Chrome已经屏蔽了11个端口了，具体如下表：</p><p>Chrome版本</p><p>屏蔽端口</p><p>Chrome 91</p><p>10080</p><p>Chrome 90</p><p>554</p><p>Chrome 87</p><p>5060、5061、69、137、161、 1719、1720、1723、6566</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/579765754a074ddcadfa110876e92a86~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="gravitysensor-api" tabindex="-1"><a class="header-anchor" href="#gravitysensor-api" aria-hidden="true">#</a> GravitySensor API</h3>',20),g={href:"https://link.zhihu.com/?target=https%3A//www.chromestatus.com/feature/5384099747332096",target:"_blank",rel:"noopener noreferrer"},x=r(`<p>GravitySensor API可以用于开发游戏，比如在赛车类游戏中，通过倾斜手机控制赛车的方向。事实上，GravitySensor API这个需求也正是是游戏引擎Unity的开发者反馈给Chrome团队的。</p><h2 id="file-system-access-api" tabindex="-1"><a class="header-anchor" href="#file-system-access-api" aria-hidden="true">#</a> File-System-access-api</h2><h4 id="_1、window-showdirectorypicker-得到文件夹句柄" tabindex="-1"><a class="header-anchor" href="#_1、window-showdirectorypicker-得到文件夹句柄" aria-hidden="true">#</a> 1、window.showDirectoryPicker() 得到文件夹句柄</h4><p><code>const rootDirHandle = await window.showDirectoryPicker();</code></p><p>![image-20210621003352705](/Users/xuyanjie/Library/Application Support/typora-user-images/image-20210621003352705.png)</p><h5 id="_1-filesystemdirectoryhandle-entries-得到文件夹下一级目录的内容文件-夹-列表" tabindex="-1"><a class="header-anchor" href="#_1-filesystemdirectoryhandle-entries-得到文件夹下一级目录的内容文件-夹-列表" aria-hidden="true">#</a> （1）FileSystemDirectoryHandle.entries() 得到文件夹下一级目录的内容文件（夹）列表</h5><p>有如下代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for await (const [key, value] of rootDirHandle.entries()) {
  console.log(value)
} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94657456d4804606b9bb492c31f895c9~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-05-28 下午7.12.39.png"></p><h5 id="_2-filesystemdirectoryhandle-getdirectoryhandle-x-得到文件夹句柄-filesystemdirectoryhandle" tabindex="-1"><a class="header-anchor" href="#_2-filesystemdirectoryhandle-getdirectoryhandle-x-得到文件夹句柄-filesystemdirectoryhandle" aria-hidden="true">#</a> （2）FileSystemDirectoryHandle.getDirectoryHandle(x, {}) 得到文件夹句柄 FileSystemDirectoryHandle</h5><p>作用：在现有目录下获取或创建新的文件夹，并得到其文件夹句柄。</p><p>有以下代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const testDirHandle = await rootDirHandle.getDirectoryHandle(&quot;testDir&quot;, {
    create: true
});
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3-filesystemdirectoryhandle-getfilehandle-x-得到文件句柄-filesystemfilehandle" tabindex="-1"><a class="header-anchor" href="#_3-filesystemdirectoryhandle-getfilehandle-x-得到文件句柄-filesystemfilehandle" aria-hidden="true">#</a> （3）FileSystemDirectoryHandle.getFileHandle(x, {}) 得到文件句柄 FileSystemFileHandle</h5><p>作用：在现有目录下获取或创建新的文件，并得到其文件句柄。</p><p>有如下代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 获得一个文件句柄
let txtFileHandle = await rootDirHandle.getFileHandle(&quot;txt.txt&quot;, {
  create: true
});
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82dec36f5a7348a086a61921b134b041~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-05-28 下午7.18.57.png"></p><h5 id="_4-filesystemfilehandle-createwritable-得到一个可写文件流-filesystemwritablefilestream" tabindex="-1"><a class="header-anchor" href="#_4-filesystemfilehandle-createwritable-得到一个可写文件流-filesystemwritablefilestream" aria-hidden="true">#</a> （4）FileSystemFileHandle.createWritable() 得到一个可写文件流 FileSystemWritableFileStream</h5><p>有以下代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 获取 txt 文件句柄
const txtFileHandle = await rootDirHandle.getFileHandle(&quot;txt.txt&quot;);
// 创建一个 txt 文件的可写文件流
const txtFileWritable = await txtFileHandle.createWritable();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-filesystemwritablefilestream-write-x-写入文件内容" tabindex="-1"><a class="header-anchor" href="#_5-filesystemwritablefilestream-write-x-写入文件内容" aria-hidden="true">#</a> （5）FileSystemWritableFileStream.write(x) 写入文件内容</h5><p>在获得了文件的可写文件流以后，便可以更改文件内容了。其实写入什么内容都可以，取决于你。这里以文本和图片为示例。</p><p>有如下代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 这里是文本文件，可以使用换行符换行，ps: 不同操作系统换行符可能不同
await txtFileWritable.write(&quot;haha\\nhaha&quot;);
// 在内容末尾再追加内容
await txtFileWritable.write(&quot;😄&quot;);
await txtFileWritable.close();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cdba5bc789f4758899bae0bfb133341~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-05-28 下午7.21.18.png"></p><h5 id="_6-filesystemfilehandle-getfile-得到文件-file" tabindex="-1"><a class="header-anchor" href="#_6-filesystemfilehandle-getfile-得到文件-file" aria-hidden="true">#</a> （6）FileSystemFileHandle.getFile() 得到文件 File</h5><p>有如下代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 获取 txt 文件句柄
const txtFileHandle = await rootDirHandle.getFileHandle(&quot;txt.txt&quot;);
// 获取 txt 文件
const txtFile = await txtFileHandle.getFile();
console.log(await txtFile.text());
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先获得 github 文件夹下的 txt.txt 文件句柄，然后获取到 txt 的 File 类型对象。File 是啥不是本文重点，不做介绍。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f04072d1f5d4fbb8c17afbf3d0e613e~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-05-28 下午7.19.27.png"></p><h5 id="_7-filesystemdirectoryhandle-removeentry-x-删除文件-夹" tabindex="-1"><a class="header-anchor" href="#_7-filesystemdirectoryhandle-removeentry-x-删除文件-夹" aria-hidden="true">#</a> （7）FileSystemDirectoryHandle.removeEntry(x, {}) 删除文件（夹）</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// recursive 为递归删除内部文件（夹）
await rootDirHandle.removeEntry(testDir, { recursive: true });
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>recursive: true 代表递归删除 testDir 目录下所有内容。比如只想删除空文件夹，有内容就跳过的情况。</p><p>那按 recursive: true 的情况执行代码。文件夹及以内文件（夹）全部被删除</p>`,34);function y(w,_){const i=n("ExternalLinkIcon");return l(),d("div",null,[o,t("p",null,[e("Chrome 91默认开启了"),t("a",p,[e("WebAssembly SIMD"),a(i)]),e("。")]),t("p",null,[t("a",h,[e("SIMD"),a(i)]),e("是"),m,e("ingle "),u,e("nstruction "),b,e("ultiple "),v,e("ata的缩写，中文术语为“单指令多数据流”，顾名思义，就是可以使用单条指令同时处理多个数据。")]),f,t("p",null,[e("Chrome 91新增了"),t("a",g,[e("GravitySensor API"),a(i)]),e("，用于获取设备（比如手机）由于地球重力而产生的加速度。")]),x])}const k=s(c,[["render",y],["__file","chrome91.html.vue"]]);export{k as default};
