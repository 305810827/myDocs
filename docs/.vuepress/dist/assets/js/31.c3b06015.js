(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{451:function(t,v,a){"use strict";a.r(v);var _=a(62),p=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"v8引擎-隐藏类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎-隐藏类"}},[t._v("#")]),t._v(" V8引擎-隐藏类")]),t._v(" "),a("h3",{attrs:{id:"_1、动态语言和静态语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、动态语言和静态语言"}},[t._v("#")]),t._v(" 1、动态语言和静态语言")]),t._v(" "),a("h4",{attrs:{id:"静态语言的效率更高"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态语言的效率更高"}},[t._v("#")]),t._v(" 静态语言的效率更高")]),t._v(" "),a("p",[t._v("![image-20210802014226000](/Users/xuyanjie/Library/Application Support/typora-user-images/image-20210802014226000.png)")]),t._v(" "),a("p",[t._v("​        JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 start.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也可以说 V8 并不知道该对象的具体的形状,当在 JavaScript 中要查询对象 start 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。")]),t._v(" "),a("p",[t._v("​\t\tC++ 在声明一个对象之前需要定义该对象的结构，并且C++ 代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中，Point 的形状是无法被改变的。")]),t._v(" "),a("p",[t._v("​        那么在 C++ 中访问一个对象的属性时，自然就知道该属性相对于该对象地址的偏移值了，比如在 C++ 中使用 start.x 的时候，编译器会直接将 x 相对于 start 的地址写进汇编指令中，那么当使用了对象 start 中的 x 属性时，CPU 就可以直接去内存地址中取出该内容即可，没有任何中间的查找环节。")]),t._v(" "),a("h4",{attrs:{id:"v8引入静态的特性-隐藏类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引入静态的特性-隐藏类"}},[t._v("#")]),t._v(" V8引入静态的特性-隐藏类")]),t._v(" "),a("p",[t._v("V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：")]),t._v(" "),a("ul",[a("li",[t._v("对象中所包含的所有的属性；")]),t._v(" "),a("li",[t._v("每个属性相对于对象的偏移量。")])]),t._v(" "),a("p",[t._v("有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对于的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。")]),t._v(" "),a("p",[t._v("在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类。")]),t._v(" "),a("p",[a("code",[t._v("let point = {x:100,y:200}")])]),t._v(" "),a("p",[t._v("![image-20210802015752999](/Users/xuyanjie/Library/Application Support/typora-user-images/image-20210802015752999.png)")]),t._v(" "),a("h4",{attrs:{id:"多个对象共用一个隐藏类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个对象共用一个隐藏类"}},[t._v("#")]),t._v(" 多个对象共用一个隐藏类")]),t._v(" "),a("p",[t._v("​\t\t现在我们知道了在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：")]),t._v(" "),a("ul",[a("li",[t._v("减少隐藏类的创建次数，也间接加速了代码的执行速度；")]),t._v(" "),a("li",[t._v("减少了隐藏类的存储空间。")])]),t._v(" "),a("p",[t._v("对象的形状是相同的，要满足以下两点：")]),t._v(" "),a("ul",[a("li",[t._v("相同的属性名称；(包括顺序)")]),t._v(" "),a("li",[t._v("相等的属性个数。")])]),t._v(" "),a("p",[a("code",[t._v("let point = {x:100,y:200};")])]),t._v(" "),a("p",[a("code",[t._v("let point2 = {x:3,y:4};")])]),t._v(" "),a("p",[t._v("![image-20210802020148473](/Users/xuyanjie/Library/Application Support/typora-user-images/image-20210802020148473.png)")]),t._v(" "),a("h4",{attrs:{id:"重新构建隐藏类关于隐藏类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重新构建隐藏类关于隐藏类"}},[t._v("#")]),t._v(" 重新构建隐藏类关于隐藏类")]),t._v(" "),a("p",[t._v("V8 为了实现隐藏类，需要两个假设条件：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("对象创建好了之后就不会添加新的属性；")])]),t._v(" "),a("li",[a("p",[t._v("对象创建好了之后也不会删除属性。")])])]),t._v(" "),a("p",[t._v("​\t\t但是，JavaScript 依然是动态语言，在执行过程中，对象的形状是可以被改变的，如果某个对象的形状改变了，隐藏类也会随着改变，这意味着 V8 要为新改变的对象重新构建新的隐藏类，这对于 V8 的执行效率来说，是一笔大的开销。")]),t._v(" "),a("p",[t._v("​\t\t通俗地理解，给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。")]),t._v(" "),a("p",[t._v("![image-20210802020343322](/Users/xuyanjie/Library/Application Support/typora-user-images/image-20210802020343322.png)")]),t._v(" "),a("p",[t._v("最后，关于隐藏类，我们记住以下几点。")]),t._v(" "),a("p",[t._v("在 V8 中，每个对象都有一个隐藏类，隐藏类在 V8 中又被称为 map。")]),t._v(" "),a("p",[t._v("在 V8 中，每个对象的第一个属性的指针都指向其 map 地址。")]),t._v(" "),a("p",[t._v("map 描述了其对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少？")]),t._v(" "),a("p",[t._v("如果添加新的属性，那么需要重新构建隐藏类。")]),t._v(" "),a("p",[t._v("如果删除了对象中的某个属性，同样也需要构建隐藏类。")]),t._v(" "),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("1，使用字面量初始化对象时，要保证属性的顺序是一致的。比如先通过字面量 x、y 的顺序创建了一个 point 对象，然后通过字面量 y、x 的顺序创建一个对象 point2，代码如下所示：")]),t._v(" "),a("p",[a("code",[t._v("let point = {x:100,y:200};")])]),t._v(" "),a("p",[a("code",[t._v("let point2 = {y:100,x:200};")])]),t._v(" "),a("p",[t._v("虽然创建时的对象属性一样，但是它们初始化的顺序不一样，这也会导致形状不同，所以它们会有不同的隐藏类，所以我们要尽量避免这种情况。")]),t._v(" "),a("p",[t._v("2，尽量使用字面量一次性初始化完整对象属性。因为每次为对象添加一个属性时，V8 都会为该对象重新设置隐藏类。")]),t._v(" "),a("p",[t._v("3，尽量避免使用 delete 方法。delete 方法会破坏对象的形状，同样会导致 V8 为该对象重新生成新的隐藏类。")])])}),[],!1,null,null,null);v.default=p.exports}}]);