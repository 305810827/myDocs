(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{503:function(v,_,t){"use strict";t.r(_);var s=t(62),n=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"js的垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js的垃圾回收机制"}},[v._v("#")]),v._v(" JS的垃圾回收机制")]),v._v(" "),t("p",[v._v("​\t\tJS的垃圾回收机制都是由js引擎实现的，大部分浏览器都有自己的js引擎，所以各自实现的垃圾回收机制都略有不同。但是主要的策略就两种:")]),v._v(" "),t("p",[v._v("1、"),t("strong",[v._v("标记清除")]),v._v("\n标记阶段：把所有活动对象做上标记。\n清除阶段：把没有标记的对象销毁。")]),v._v(" "),t("p",[v._v("​\t缺点：没有被清除的对象位置不变，导致清楚后的空闲内存空间不连续（内存碎片）")]),v._v(" "),t("p",[v._v("2、"),t("strong",[v._v("引用计数")])]),v._v(" "),t("p",[v._v("​\t一个值赋给了一个变量，这个值引用计数加一，又被赋给另一个变量就再加一（类推），另一个值要是覆盖了原本已经赋值的变量，则这个值引用计数减一。")]),v._v(" "),t("p",[v._v("​\t缺点：1、需要一个不知上限的计数器。2、循环引用无法回收")]),v._v(" "),t("h4",{attrs:{id:"v8的垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8的垃圾回收机制"}},[v._v("#")]),v._v(" v8的垃圾回收机制")]),v._v(" "),t("p",[v._v("​\t\t分代式垃圾回收：分为"),t("strong",[v._v("新生代区域")]),v._v("和"),t("strong",[v._v("老生代区域")]),v._v("。新生代区域容量小，会保存存活较短、体积较小的对象。老生代反之。不同分区的垃圾回收机制与回收频率都不同。")]),v._v(" "),t("p",[t("strong",[v._v("新生代区")])]),v._v(" "),t("p",[v._v("​\t\t新生代区又分为"),t("strong",[v._v("使用区")]),v._v("和"),t("strong",[v._v("空闲区")]),v._v("，通过 "),t("code",[v._v("Scavenge")]),v._v(" 算法把使用区活着的对象复制到空闲区并排序（"),t("strong",[v._v("解决内存碎片化问题")]),v._v("），随后清理使用区剩余未标记的垃圾，此时使用区变成空闲区，空闲区变成使用区。上述过程反复，一个对象多次复制后仍存活就直接移到"),t("strong",[v._v("老生代区")]),v._v("，就像两个杯子，一杯水倒来倒去，一直没撒出去的就是存活较久的，可以移到"),t("strong",[v._v("老生代区")]),v._v("。或者当对象复制到空闲区，内存超过空闲区的25%时，也会直接移到老生代区。")]),v._v(" "),t("p",[t("strong",[v._v("老生代区")])]),v._v(" "),t("p",[v._v("​\t\t老生代区使用"),t("strong",[v._v("标记清除")]),v._v("("),t("code",[v._v("Mark-Sweep")]),v._v(")，从根节点(dom、window、global)遍历标记活着的对象，回收器定时清理死亡的对象。使用"),t("strong",[v._v("标记整理算法")]),v._v("把标记的对象向内存一端移动（"),t("strong",[v._v("解决标记清除的内存碎片化问题")]),v._v("）")]),v._v(" "),t("p",[v._v("tip： "),t("code",[v._v("Scavenge")]),v._v("只复制活着的对象，"),t("code",[v._v("Mark-Sweep")]),v._v("只清除死亡的对象。活对象在新生代区较少，死对象在老生代中交少，这是两种回收方式高效的原因。")]),v._v(" "),t("p",[t("strong",[v._v("并行回收")])]),v._v(" "),t("p",[v._v("​\t\tjs是单线程，所以垃圾回收会阻塞js脚本的执行，"),t("strong",[v._v("并行回收")]),v._v("就是开启辅助线程帮助垃圾回收。")]),v._v(" "),t("p",[v._v("​\t\t缺点：像老生代区活着的对象大而多，就算是并行任务，一次的清理任务也可能过重导致阻塞过长，所以需要使用"),t("strong",[v._v("增量标记")]),v._v("和"),t("strong",[v._v("惰性清理")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("增量标记")])]),v._v(" "),t("p",[v._v("​\t\t把回收任务分成一小步一小步的，执行完一小步再把主线程交给js，这样交替增量执行完一次标记任务，但可能会出现执行任务程序时内存中标记好的对象引用关系被修改的问题，所以需要引入"),t("strong",[v._v("三色标记法")]),v._v("和"),t("strong",[v._v("写屏障法")]),v._v("来解决。")]),v._v(" "),t("p",[t("strong",[v._v("惰性清理")])]),v._v(" "),t("p",[v._v("​\t\t在内存充足情况先优先执行js代码，主线程空闲时才清理垃圾，无需一次去清理完未标记的对象，逐一清理，配合增量标记使用")]),v._v(" "),t("p",[v._v("​\t\t缺点：增量标记后惰性清理，没有减少占用主线程的时间，甚至增加了。")]),v._v(" "),t("p",[t("strong",[v._v("并发回收")])]),v._v(" "),t("p",[v._v("​\t\t完全在辅助线程执行，不会占用主线程。")]),v._v(" "),t("p",[v._v("​\t\t缺点：需要考虑垃圾回收器在辅助线程已经做的标记或者正在做标记时，js对象引用的改变，需要额外实现读写锁机制。")]),v._v(" "),t("p",[v._v("v8垃圾回收机制就是根据上述方法的优缺点，结合使用。")]),v._v(" "),t("p",[v._v("参考：")]),v._v(" "),t("p",[v._v("1、《深入浅出nodejs》5.1- v8的垃圾回收机制与内存限制")]),v._v(" "),t("p",[v._v("2、掘金：https://juejin.cn/post/6981588276356317214?share_token=6cecbce3-8f54-4e4a-9049-d73399fa76e8")])])}),[],!1,null,null,null);_.default=n.exports}}]);