{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{480:function(n,e,s){\"use strict\";s.r(e);var t=s(62),a=Object(t.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[s(\"h3\",{attrs:{id:\"观察者模式\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#观察者模式\"}},[n._v(\"#\")]),n._v(\" \"),s(\"strong\",[n._v(\"观察者模式\")])]),n._v(\" \"),s(\"p\",[n._v(\"观察者模式：定义了对象间一种一对多的依赖关系，当目标对象 Subject 的状态发生改变时，所有依赖它的对象 Observer 都会得到通知。\")]),n._v(\" \"),s(\"ul\",[s(\"li\",[s(\"p\",[n._v(\"一个目标者对象 Subject，拥有方法：添加 / 删除 / 通知 Observer；\")])]),n._v(\" \"),s(\"li\",[s(\"p\",[n._v(\"多个观察者对象 Observer，拥有方法：接收 Subject 状态变更通知并处理；\")])])]),n._v(\" \"),s(\"p\",[n._v(\"目标对象 Subject 状态变更时，通知所有 Observer。\")]),n._v(\" \"),s(\"p\",[n._v(\"代码实现：\")]),n._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[n._v(\"class Subject {\\n    constructor() {\\n        this.observers = []; //观察者列表\\n    }\\n    //添加\\n    add(observer) {\\n        this.observers[this.observers.length] = observer;\\n    }\\n    //删除\\n    remove(observer) {\\n        let idx = this.observers.findIndex(item => item === observer);\\n        idx > -1 && this.observers.splice(idx, 1);\\n    }\\n    //通知\\n    notify() {\\n        for (let observer of this.observers) {\\n            observer.update();\\n        }\\n    }\\n}\\n//观察者类\\nclass Observer {\\n    constructor(name) {\\n        this.name = name;\\n    }\\n    // 目标对象更新时触发的回调\\n    update() {\\n        console.log(`i am ${this.name}`);\\n    }\\n}\\n//实例化目标者\\nlet subject = new Subject();\\n//实例化两个观察者\\nlet obs1 = new Observer('前端');\\nlet obs2 = new Observer('后端');\\n//向目标者添加观察者\\nsubject.add(obs1);\\nsubject.add(obs2);\\n// 目标者通知更新\\nsubject.notify();\\n\")])])]),s(\"p\",[n._v(\"优势：观察者被动接收更新，时间上解耦，实时接收目标者更新状态。\")]),n._v(\" \"),s(\"p\",[n._v(\"缺点：观察者模式并没有实现两个类的完全解耦，目标对象中还维护着观察者列表。从而引出来发布订阅模式，相比于观察者模式多了一个中间调度层，把两者的依赖关系维护起来，让两者完全解耦。\")]),n._v(\" \"),s(\"h3\",{attrs:{id:\"发布订阅模式\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#发布订阅模式\"}},[n._v(\"#\")]),n._v(\" 发布订阅模式\")]),n._v(\" \"),s(\"p\",[n._v(\"发布订阅模式：基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。\")]),n._v(\" \"),s(\"p\",[n._v(\"发布订阅模式与观察者模式的不同，“第三者” （事件中心）出现。目标对象并不直接通知观察者，而是通过事件中心来派发通知。\")]),n._v(\" \"),s(\"p\",[n._v(\"代码实现：\")]),n._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[n._v(\"//事件中心\\nclass pubSub {\\n    constructor(){\\n        this.list = {}\\n    }\\n\\n    subscribe (key, fn) {\\n        if (!this.list[key]) {\\n            this.list[key] = [fn]\\n        } else {\\n            this.list[key].push(fn)\\n        }\\n    }\\n\\n    publish (key) {\\n        for (let item of this.list[key]) {\\n            item(...[...arguments].splice(1))\\n        }\\n    }\\n    unSubscribe (key, fn) {\\n        let fnList = this.list[key]\\n        if (!fnList) return\\n        if (!fn) {\\n            fnList && (fnList.length = 0)\\n        } else {\\n            fnList.forEach((item, index) => {\\n                if (item === fn) fnList.splice(index, 1)\\n            })\\n        }\\n    }\\n}\\n\\nlet myPubSub = new pubSub()\\n\\n// 订阅\\nmyPubSub.subscribe('start', (a) => {\\n    console.log('start', a)\\n})\\nmyPubSub.subscribe('start', (a) => {\\n    console.log('start1', a)\\n})\\nlet end = (a) => {\\n    console.log('end', a)\\n}\\nmyPubSub.subscribe('end', end)\\n\\n//发布\\nmyPubSub.publish('start', 'hello')\\nmyPubSub.publish('end', 'hello')\\n\\n//取消订阅\\nmyPubSub.unSubscribe('start')\\nmyPubSub.publish('start', 'hello')\\n\")])])]),s(\"h3\",{attrs:{id:\"模式的应用\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#模式的应用\"}},[n._v(\"#\")]),n._v(\" 模式的应用\")]),n._v(\" \"),s(\"p\",[n._v(\"1、 DOM  事件监听就是 “发布订阅模式” 的典型应用：\")]),n._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[n._v(\"//事件\\nlet loginBtn = document.getElementById('#loginBtn');\\n//监听回调函数(指定事件)\\nfunction notifyClick(){\\n\\tconsole.log('我被点击了)\\n}\\n//添加事件监听\\nloginBtn.addEventListener('click', notifyClick);\\n//触发点击,事件中心派发指定事件\\nloginBtn.click();\\n//取消事件监听\\nloginBtn.removeEventlistener('click', notifyClick);\\n\")])])]),s(\"p\",[n._v(\"2、jQuery 的 on 和 trigger，$.callback();\")]),n._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[n._v(\"// 自定义事件，自定义回调\\nvar callbacks = $.Callbacks() // 注意大小写\\ncallbacks.add(function (info) {\\n\\tconsole.log('fn1', info)\\n})\\ncallbacks.add(function (info) {\\n\\tconsole.log('fn2', info)\\n})\\ncallbacks.add(function (info) {\\n\\tconsole.log('fn3', info)\\n})\\n//添加完后统一触发。\\ncallbacks.fire('gogogo')\\n\")])])]),s(\"p\",[n._v(\"3、Vue 的双向数据绑定\")]),n._v(\" \"),s(\"p\",[n._v(\"4、Vue 的父子组件通信 $on/$emit\")]),n._v(\" \"),s(\"p\",[n._v(\"5、promise\")]),n._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[n._v(\"var src = 'http://www.imooc.com/static/img/index/logo_new.png'\\nvar result = loadImg(src)\\nresult.then(function (img) {\\n  console.log('success 1')\\n}, function () {    \\n  console.log('failed 1')\\n})\\n// then就是一个观察者，等待前一个处理完成\\n\")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);","extractedComments":[]}