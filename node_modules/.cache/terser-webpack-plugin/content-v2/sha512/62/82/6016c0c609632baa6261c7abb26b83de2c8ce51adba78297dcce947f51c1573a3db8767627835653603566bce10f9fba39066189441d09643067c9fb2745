{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{526:function(e,s,a){\"use strict\";a.r(s);var t=a(62),o=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"resolve\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#resolve\"}},[e._v(\"#\")]),e._v(\" \"),a(\"strong\",[e._v(\"Resolve\")])]),e._v(\" \"),a(\"p\",[e._v(\"Webpack 在启动后会从配置的入口模块出发找出所有依赖的模块，Resolve 配置 Webpack 如何寻找模块所对应的文件。 Webpack 内置 JavaScript 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你也可以根据自己的需要修改默认的规则。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"alias\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#alias\"}},[e._v(\"#\")]),e._v(\" alias\")]),e._v(\" \"),a(\"p\",[e._v(\"resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。例如使用以下配置：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// Webpack alias 配置\\nresolve:{\\n  alias:{\\n    components: './src/components/'\\n  }\\n}\\n\")])])]),a(\"p\",[e._v(\"当你通过 \"),a(\"code\",[e._v(\"import Button from 'components/button\")]),e._v(\" 导入时，实际上被 \"),a(\"code\",[e._v(\"alias\")]),e._v(\" 等价替换成了 \"),a(\"code\",[e._v(\"import Button from './src/components/button'\")]),e._v(\" 。\")]),e._v(\" \"),a(\"p\",[e._v(\"这样做可能会命中太多的导入语句，alias 还支持 \"),a(\"code\",[e._v(\"$\")]),e._v(\" 符号来缩小范围到只命中以关键字结尾的导入语句：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"resolve:{\\n  alias:{\\n    'react$': '/path/to/react.min.js'\\n  }\\n}\\n\")])])]),a(\"p\",[e._v(\"react$ 只会命中以 react 结尾的导入语句，即只会把 \"),a(\"code\",[e._v(\"import 'react'\")]),e._v(\" 关键字替换成 \"),a(\"code\",[e._v(\"import '/path/to/react.min.js'\")])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"extensions\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#extensions\"}},[e._v(\"#\")]),e._v(\" extensions\")]),e._v(\" \"),a(\"p\",[e._v(\"在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试访问文件是否存在。 resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认是：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"extensions: ['.js', '.json']\\n\")])])]),a(\"p\",[e._v(\"也就是说当遇到 require('./data') 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件， 如果还是找不到就报错。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"modules\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#modules\"}},[e._v(\"#\")]),e._v(\" modules\")]),e._v(\" \"),a(\"p\",[e._v(\"resolve.modules 配置 Webpack 去哪些目录下寻找第三方模块，默认是只会去 node_modules 目录下寻找。 有时你的项目里会有一些模块会大量被其它模块依赖和导入，由于其它模块的位置分布不定，针对不同的文件都要去计算被导入模块文件的相对路径， 这个路径有时候会很长，就像这样 import '../../../components/button' 这时你可以利用 modules 配置项优化，假如那些被大量导入的模块都在 ./src/components 目录下，把 modules 配置成\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"modules:['./src/components','node_modules']\\n\")])])]),a(\"p\",[e._v(\"后，你可以简单通过 import 'button' 导入。\")])])}),[],!1,null,null,null);s.default=o.exports}}]);","extractedComments":[]}